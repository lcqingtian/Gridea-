<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World 测试</title>
    <url>/2024/03/15/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>建立自己的博客</title>
    <url>/2024/03/12/%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h1><h2 id="1-安装-Node-js-和-npm"><a href="#1-安装-Node-js-和-npm" class="headerlink" title="1. 安装 Node.js 和 npm"></a>1. 安装 Node.js 和 npm</h2><ul>
<li>前往 <a href="https://nodejs.org/">Node.js 官网</a> 下载并安装最新版本的 Node.js。</li>
<li>安装完成后，你可以在命令行中运行以下命令来验证是否成功安装：<br>node -v<br>npm -v</li>
</ul>
<p>Copy code</p>
<h2 id="2-安装-Git"><a href="#2-安装-Git" class="headerlink" title="2. 安装 Git"></a>2. 安装 Git</h2><ul>
<li>如果你的系统中还没有安装 Git，你可以在 <a href="https://git-scm.com/">Git 官网</a> 下载并安装。</li>
<li>安装完成后，你可以在命令行中运行以下命令来验证是否成功安装：<br>git –version</li>
</ul>
<h2 id="3-全局安装-Hexo"><a href="#3-全局安装-Hexo" class="headerlink" title="3. 全局安装 Hexo"></a>3. 全局安装 Hexo</h2><ul>
<li>打开命令行终端，运行以下命令来全局安装 Hexo-cli：<br>npm install -g hexo-cli</li>
</ul>
<p>markdown<br>Copy code</p>
<h2 id="4-初始化-Hexo-项目"><a href="#4-初始化-Hexo-项目" class="headerlink" title="4. 初始化 Hexo 项目"></a>4. 初始化 Hexo 项目</h2><ul>
<li>在你想要创建 Hexo 博客的目录中，打开命令行终端，运行以下命令来初始化一个新的 Hexo 项目：<br>hexo init myblog</li>
</ul>
<h2 id="5-进入项目目录并安装依赖"><a href="#5-进入项目目录并安装依赖" class="headerlink" title="5. 进入项目目录并安装依赖"></a>5. 进入项目目录并安装依赖</h2><ul>
<li><p>进入项目目录：<br>cd myblog</p>
</li>
<li><p>在项目目录中运行以下命令来安装项目所需的依赖：<br>npm install</p>
</li>
</ul>
<h2 id="6-启动本地服务器"><a href="#6-启动本地服务器" class="headerlink" title="6. 启动本地服务器"></a>6. 启动本地服务器</h2><ul>
<li>在项目目录中运行以下命令来启动 Hexo 的本地服务器：<br>hexo server</li>
</ul>
<p>less</p>
<ul>
<li>这将启动一个本地服务器，默认情况下访问地址为 <a href="http://localhost:4000/">http://localhost:4000</a>。</li>
</ul>
<p>现在，你已经成功安装和初始化了 Hexo 项目。你可以开始编写文章、定制主题，并通过部署将博客发布到线上。<br>这是一个使用Markdown格式编写的Hexo安装步骤，你可以将其保存为.md文件，然后在Hexo博客中使用。</p>
<h2 id="部署GitHub-Pages"><a href="#部署GitHub-Pages" class="headerlink" title="部署GitHub Pages"></a>部署GitHub Pages</h2><p>我们假定你已经有一个GitHub账号而且已经配置好git了，不知道应该怎么做的话可以参考这篇博客。</p>
<p>现在新建一个仓库（Create a new repository），Repository name填写为&lt;你的GitHub用户名&gt;.github.io，例如“ChaoiteC.github.io”，同时仓库可见性必须为Public（对所有人可见）。</p>
<p>如果操作正确，你会在仓库设置中找到Page选项。</p>
<p>现在打开博客根目录下的_config.yml，找到Deployment相关配置项，如下填写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">deploy:<br>  <span class="hljs-built_in">type</span>: git<br>  repo: git@github.com:&lt;你的GitHub用户名&gt;/&lt;你的GitHub用户名&gt;.github.io.git<br>  branch: main<br></code></pre></td></tr></table></figure>
<p>你可能注意到官方文档与一些其他教程中repo项填写的是http链接，这也是可以的，但在使用GitHub Actions部署时可能会遭遇拒绝访问的问题。</p>
<p>安装hexo-deployer-git:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure>
<p>执行下面命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo clean<br>$ hexo g<br>$ hexo deploy 或者简写为： $ hexo d<br>或者简写为：<br><br>bash<br>Copy code<br>$ hexo d -g<br></code></pre></td></tr></table></figure>
<p>deploy命令会将public目录中的文件和目录推送至_config.yml中指定的远端仓库和分支中，并且完全覆盖该分支下的已有内容。</p>
<p>如果一切工作正常，现在你可以在&lt;你的GitHub用户名&gt;.github.io中看到网站内容。</p>
<p>##GitHub Actions自动部署（可选）<br>我们很快注意到，一旦你离开现在使用的设备，你就无法修改网站内容。当你更换设备时，你不得不将上述步骤全部重复。一旦设备出现故障更是会损失惨重。这些矛盾呼吁我们采取方法，要求我们能自动地储存与部署博客文件，而不受手上设备的限制。</p>
<p>GitHub Actions为我们在需要的时候创建一个容器，我们在容器中安装软件并处理我们的博客文件，最后部署到Pages仓库中。现在我们来实现它。</p>
<p>前提<br>首先在Github上新建一个仓库用来储存我们的博客文件，通常我们将其设为私有的。</p>
<p>如果你安装了VS Code，这时候你可以在博客根目录右键菜单中选择“在终端中打开”来启动Windows Powershell，然后输入并执行：</p>
<p>code .<br>此命令将会启动VS Code并在其中打开这个文件夹。然后你可以在侧边栏中打开源代码管理页面，从GitHub添加远程库。只需要按照提示操作，你最终能将整个目录下的文件上传到仓库中（被.gitignore指定的文件&#x2F;文件夹不会上传）。</p>
<p>我们将上面内容视为准备操作，如果你不知道如何操作，可以寻求搜索引擎的帮助。</p>
<p>部署密钥<br>现在在“git bash here”中执行下面命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ ssh-keygen -f github-deploy-key<br></code></pre></td></tr></table></figure>
<p>这个命令将生成部署密钥，你只需要一直按空格，根目录下就会出现两个文件：github-deploy-key和github-deploy-key.pub。</p>
<p>注意</p>
<p>正如其名字，除非你确定自己在做什么，否则你不应该将密钥直接上传到仓库（尤其是公共仓库）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">在博客源文件仓库中依序打开Settings-&gt;Secrets and variables-&gt;Actions-&gt;New repository secret。<br></code></pre></td></tr></table></figure>

<p>在Name中填写“HEXO_DEPLOY_PRI”，在Value中填写github-deploy-key文件中的全部内容（包括头尾的文字）。然后Add secret。</p>
<p>在Page仓库中依序打开Settings-&gt;Deploy keys-&gt;Add deploy key。</p>
<p>在Title中填写“HEXO_DEPLOY_PUB”，在Key中填写github-deploy-key.pub文件中的全部内容，勾选Allow write access，然后Add key。</p>
<p>配置GitHub Actions<br>在博客根目录下创建.github&#x2F;workflows&#x2F;deploy.yml文件，目录结构如下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">.<br>└── .github<br>    └── workflows<br>        └── deploy.yml<br>在deploy.yml文件中粘贴下面内容并在对应地方作改动。<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Action&#x27;s Name</span><br>name: AutoDeploy<br><br>on:<br>  <span class="hljs-comment"># Triggering Condition 1 Main Branch Performs The Task After Receiving Push</span><br>  push:<br>    branches:<br>      - main<br>  <span class="hljs-comment"># Triggering Condition 2 Manual Button</span><br>  workflow_dispatch:<br><br><span class="hljs-comment"># Putting Environment Variables Here You Need To Replace It With Your Own</span><br><span class="hljs-built_in">env</span>:<br>  <span class="hljs-comment"># After Hexo Compiles Use This Git User To Deploy To The Github Warehouse</span><br>  GIT_USER: &lt;你的GitHub用户名&gt;<br>  <span class="hljs-comment"># After Hexo Compiles Use This Git Mailbox To Deploy To The Github Warehouse</span><br>  GIT_EMAIL: &lt;你的GitHub用户邮箱&gt;<br>  <span class="hljs-comment"># The Git Hub Warehouse To Be Deployed After Hexo Compiles</span><br>  GIT_DEPLOY_REPO: &lt;你的GitHub用户名&gt;/&lt;你的GitHub用户名&gt;.github.io<br>  <span class="hljs-comment"># Hexo Compiles The Branch To Deploy After Compilation</span><br>  GIT_DEPLOY_BRANCH: main<br><br><span class="hljs-built_in">jobs</span>:<br>  build:<br>    name: Build on node <span class="hljs-variable">$&#123;&#123; matrix.node_version &#125;</span>&#125; and <span class="hljs-variable">$&#123;&#123; matrix.os &#125;</span>&#125;<br>    runs-on: ubuntu-latest<br>    <span class="hljs-keyword">if</span>: github.event.repository.owner.id == github.event.sender.id<br>    strategy:<br>      matrix:<br>        os: [ubuntu-latest]<br>        node_version: [16.x]<br><br>    steps:<br>      - name: Checkout<br>        uses: actions/checkout@v4<br><br>      - name: Checkout deploy repo<br>        uses: actions/checkout@v4<br>        with:<br>          repository: <span class="hljs-variable">$&#123;&#123; env.GIT_DEPLOY_REPO &#125;</span>&#125;<br>          ref: <span class="hljs-variable">$&#123;&#123; env.GIT_DEPLOY_BRANCH &#125;</span>&#125;<br>          path: .deploy_git<br><br>      - name: Use Node.js <span class="hljs-variable">$&#123;&#123; matrix.node_version &#125;</span>&#125;<br>        uses: actions/setup-node@v1<br>        with:<br>          node-version: <span class="hljs-variable">$&#123;&#123; matrix.node_version &#125;</span>&#125;<br><br>      - name: Configuration environment<br>        <span class="hljs-built_in">env</span>:<br>          HEXO_DEPLOY_PRI: <span class="hljs-variable">$&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;</span>&#125;<br>        run: |<br>          sudo timedatectl set-timezone <span class="hljs-string">&quot;Asia/Shanghai&quot;</span><br>          <span class="hljs-built_in">mkdir</span> -p ~/.ssh/<br>          <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$HEXO_DEPLOY_PRI</span>&quot;</span> &gt; ~/.ssh/id_rsa<br>          <span class="hljs-built_in">chmod</span> 600 ~/.ssh/id_rsa<br>          ssh-keyscan -t rsa github.com &gt;&gt; ~/.ssh/known_hosts<br>          git config --global user.name <span class="hljs-variable">$GIT_USER</span><br>          git config --global user.email <span class="hljs-variable">$GIT_EMAIL</span><br><br>      - name: Install dependencies<br>        run: |<br>          npm install hexo-cli -g<br>          <span class="hljs-comment"># Install According To The Components You Installed</span><br>          npm install - gulp gulp-uglify hexo hexo-deployer-git hexo-generator-archive hexo-generator-category hexo-generator-feed hexo-generator-index hexo-generator-search hexo-generator-searchdb hexo-generator-sitemap hexo-generator-tag hexo-renderer-ejs hexo-renderer-marked hexo-renderer-pug hexo-renderer-stylus hexo-server hexo-tag-cloud hexo-word-counter readable-stream uglify-es --save<br><br>      - name: Deploy hexo<br>        run: |<br>          npm run deploy<br></code></pre></td></tr></table></figure>
<p>现在你可以尝试在博客源文件仓库中作一点改动并推送到远程库，接着在仓库的Actions页面中观察工作是否正常（不被打红叉）。如果正常，大约在1-2分钟内会完成自动部署任务，你能在Pages上确认到更改。</p>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
  </entry>
  <entry>
    <title>软考数据库</title>
    <url>/2024/03/12/ruankao/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>软考</category>
      </categories>
  </entry>
  <entry>
    <title>案例分析</title>
    <url>/2024/03/12/ruankao/%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="必背知识点"><a href="#必背知识点" class="headerlink" title="必背知识点"></a>必背知识点</h2><h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><p>质量属性<br>性能，可靠性，可用性，安全性，可修改性，互操作性，功能性，可变性</p>
<p>敏感点:为了实现某种特定的质量属性，一个或者多个构件所具有的特性。  </p>
<p>权衡点：影响多个质量属性的特性，是多个质量属性的敏感点。  </p>
<p>架构风险：是一种常规概念，既可能引起风险的因素，称为风险点。某个做法如果有隐患，有可能 导致一些问题，就成为风险点，如果某件事情可行，是可接受的，则是非风险点。</p>
<h2 id="架构风格"><a href="#架构风格" class="headerlink" title="架构风格"></a>架构风格</h2><p>概念<br>什么是架构风格</p>
<ul>
<li>软件体系结构风格是描述某一特定应用领域中系统组织方式的惯用模式。架构风格定义一个系统家族，即-个架构定义、一个词汇表和一组约束。词汇表中包含一些构件和连接件类型，而这组约束指出系统是如何将这些构件和连接件组合起来的。</li>
<li>架构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将各个模块和子系统有效地组织成一个完整的系统。对软件架构风格的研究和实践促进对设计的重用，一些经过实践证实的解决方案也可以可靠地用于解决新的问题。</li>
<li>架构设计的一个核心问题是能否达到架构级的软件复用<br>架构风格定义了用于描述系统的术语表和一组指导构建系统的规则，</li>
</ul>
<h2 id="架构风格分类"><a href="#架构风格分类" class="headerlink" title="架构风格分类"></a>架构风格分类</h2><h3 id="数据流风格"><a href="#数据流风格" class="headerlink" title="数据流风格"></a>数据流风格</h3><p>批处理<br>管道过滤器<br>二者区别在于批处理前后构件不一定有关联，并且是作为整体传递，即必须前一个执行完才能执行下一个。管道-过滤器是前一个输出作为后一个输入，前面执行到部分可以开始下一个的执行。<br>优点：独立性好，复用性好，可扩展良好<br>缺点：交互性差</p>
<h3 id="调用返回风格"><a href="#调用返回风格" class="headerlink" title="调用返回风格"></a>调用返回风格</h3><p>◆主程序&#x2F;子程序:单线程控制，把问题划分为若干个处理步骤，构件即为主程序和子程序，子程序通常可合成为模块。过程调用作为交互机制，充当连接件的角色。个人认为netty符合这种模式 主程序处理连接 子程序处理请求<br>◆面向对象:构件是对象，对象是抽象数据类型的实例。连接件即使对象间交互的方式对象是通过函数和过程的调用来交互的，<br>◆层次结构:构件组成一个层次结构，连接件通过决定层间如何交互的协议来定义。每层为上一层提供服务，使用下一层的服务，只能见到与自己邻接的层。修改某一层，最多影响其相邻的两层(通常只能影响上层)<br>◆层次结构优点:支持基于可增加抽象层的设计，允许将一个复杂问题分解成一个增量步序列的实现。<br>  不同的层次处于不同的抽象级别，越靠近底层，抽象级别越高。<br>  由于每一层最多只影响两层，同时只要给相邻层提供相同的接口，允许每层用不同的方法实现，同样为软件复用提供了强大的支持。<br>◆缺点:<br>1.并不是每个系统都可以很容易的划分为分层的模式。<br>2.很难找到一个合适的、正确的层次抽象方法。</p>
<h3 id="独立构件风格"><a href="#独立构件风格" class="headerlink" title="独立构件风格"></a>独立构件风格</h3><p>进程通信<br>事件驱动系统 （隐式调用） （题目字眼 <span style="color:blue">事件</span>）</p>
<h3 id="仓库风格"><a href="#仓库风格" class="headerlink" title="仓库风格"></a>仓库风格</h3><p>优点：交互性好，可扩展性好（相比数据流风格此风格可扩展性更好）<br>缺点：</p>
<h3 id="虚拟机风格"><a href="#虚拟机风格" class="headerlink" title="虚拟机风格"></a>虚拟机风格</h3><p>解释器 （题目字眼 ，一般题目描述出现 <span style="color:blue">可视化 解释代码 可视化编程</span> 等都是这种风格）<br>基于规则的系统</p>
<h3 id="闭环"><a href="#闭环" class="headerlink" title="闭环"></a>闭环</h3><h3 id="C2风格"><a href="#C2风格" class="headerlink" title="C2风格"></a>C2风格</h3>]]></content>
      <categories>
        <category>软考</category>
      </categories>
  </entry>
  <entry>
    <title>Redis实现限流和分布式锁</title>
    <url>/2024/03/12/Redis/Redis%E9%94%81/</url>
    <content><![CDATA[<p>##Redis实现限流和分布式锁<br>首先添加jar包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">&lt;dependency&gt;<br>		&lt;groupId&gt;org.redisson&lt;/groupId&gt;<br>		&lt;artifactId&gt;redisson&lt;/artifactId&gt;<br>		&lt;version&gt;3.24.3&lt;/version&gt;<br>	&lt;/dependency&gt;<br></code></pre></td></tr></table></figure>
<p>如果缺少类请查看这个地址<br><a href="https://mvnrepository.com/artifact/org.redisson/redisson/3.24.3">https://mvnrepository.com/artifact/org.redisson/redisson/3.24.3</a><br>他会显示这个包所相关的jar包和版本号<br>然后就是配置redisson  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">package com.rfca.config;<br><br>import org.redisson.Redisson;<br>import org.redisson.config.Config;<br>import org.springframework.context.annotation.Bean;<br>import org.springframework.stereotype.Component;<br><br>@Component<br>public class RedisConfig &#123;<br>    // 1. Create config object<br>    @Bean<br>    public Redisson <span class="hljs-function"><span class="hljs-title">redisson</span></span>() &#123;<br><br>        Config config = new Config();<br><br>        config.useSingleServer()<br>                .setAddress(<span class="hljs-string">&quot;redis://127.0.0.1:6379&quot;</span>)<br>                .setPassword(<span class="hljs-string">&quot;12345&quot;</span>); // 替换为你的 Redis 密码<br>        <span class="hljs-built_in">return</span> (Redisson) Redisson.create(config);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>当我们实现高并发的时候，还需要考虑限流<br>这是我的一个实现类</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">package com.rfca.config;<br><br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.stereotype.Component;<br>import redis.clients.jedis.ShardedJedis;<br>import redis.clients.jedis.ShardedJedisPool;<br><br>@Component<br>public class RateLimiter &#123;<br>    @Autowired<br>    private ShardedJedisPool shardedJedisPool;<br><br>    public boolean isAllowed(String key, int <span class="hljs-built_in">limit</span>, int windowSizeInSeconds) &#123;<br>        try (ShardedJedis jedis = shardedJedisPool.getResource()) &#123;<br>            String redisKey = String.format(<span class="hljs-string">&quot;rate_limiter:%s&quot;</span>, key);<br><br>            // 获取当前时间戳<br>            long timestamp = System.currentTimeMillis() / 1000;<br><br>            // 获取窗口起始时间<br>            long windowStart = timestamp - windowSizeInSeconds;<br><br>            // 统计窗口内的请求数量<br>            long count = jedis.zcount(redisKey, windowStart, timestamp);<br><br>            // 判断是否允许请求<br>            <span class="hljs-built_in">return</span> count &lt; <span class="hljs-built_in">limit</span>;<br>        &#125; catch (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-built_in">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure>
<p>编写测试代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">@GetMapping(<span class="hljs-string">&quot;/limited-resource&quot;</span>)<br>    public ResponseEntity&lt;String&gt; accessLimitedResource(HttpServletRequest request) &#123;<br>        String key = <span class="hljs-string">&quot;resourceAccessKey&quot;</span>; // 用于标识资源的键<br>        int <span class="hljs-built_in">limit</span> = 10000; // 限制次数<br>        int windowSizeInSeconds = 60; // 时间窗口，例如1分钟<br><br>        boolean isAllowed = rateLimiter.isAllowed(key, <span class="hljs-built_in">limit</span>, windowSizeInSeconds);<br>        <span class="hljs-keyword">if</span> (isAllowed) &#123;<br>            // 获取缓存<br>            String keyparam = request.getParameter(<span class="hljs-string">&quot;30610002&quot;</span>);<br>            RBucket&lt;Integer&gt; bucket = redisson.getBucket(keyparam); // 获取 RBucket 对象<br>            String lock = <span class="hljs-string">&quot;mylock&quot;</span>; // 此处使用全局锁，可以针对不同资源进行加锁，减少锁的粒度<br>            RLock lock1 = redisson.getLock(lock);<br>            Integer nums1 = bucket.get();<br>            <span class="hljs-keyword">if</span> (nums1 == 0) &#123;<br>                log.info(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>                <span class="hljs-built_in">return</span> ResponseEntity.status(HttpStatus.TOO_MANY_REQUESTS).body(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>            &#125;<br>            lock1.lock();//阻塞式等待，默认加的锁都是30s时间<br>            try &#123;<br>                log.info(<span class="hljs-string">&quot;加锁成功，执行业务...&quot;</span> + Thread.currentThread().getId()); // 打印获取到锁的线程ID<br>                Integer nums = bucket.get();<br>                <span class="hljs-keyword">if</span> (nums != null &amp;&amp; nums &gt; 0) &#123;<br>                    String parkingLotId = request.getParameter(<span class="hljs-string">&quot;30610002&quot;</span>);<br>                    SelectByparkinglotidResult selectByparkinglotidResult = monthlyCardRulesMapper.selectByparkinglotid(parkingLotId).get(0);<br>                    MonthlyCardRules monthlyCardRules = new MonthlyCardRules();<br>                    monthlyCardRules.setId(selectByparkinglotidResult.getId());<br>                    monthlyCardRules.setNums(nums - 1);<br>                    monthlyCardRulesMapper.updateByPrimaryKeySelective(monthlyCardRules);<br>                    log.info(<span class="hljs-string">&quot;更新成功&quot;</span>);<br>                    bucket.set(nums - 1);<br>                    <span class="hljs-built_in">return</span> ResponseEntity.ok(<span class="hljs-string">&quot;请求成功&quot;</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    log.info(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>                    <span class="hljs-built_in">return</span> ResponseEntity.status(HttpStatus.TOO_MANY_REQUESTS).body(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>                &#125;<br>            &#125; catch (Exception e) &#123;<br>                log.info(<span class="hljs-string">&quot;获取锁失败&quot;</span>);<br>                <span class="hljs-built_in">return</span> ResponseEntity.ok(<span class="hljs-string">&quot;没有抢到&quot;</span>);<br>            &#125; finally &#123;<br>                <span class="hljs-keyword">if</span> (lock1.isHeldByCurrentThread()) &#123;<br>                    log.info(<span class="hljs-string">&quot;释放锁...&quot;</span> + Thread.currentThread().getId());<br>                    lock1.unlock();<br>                &#125;<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">return</span> ResponseEntity.status(HttpStatus.TOO_MANY_REQUESTS).body(<span class="hljs-string">&quot;请求过多，请稍后再试&quot;</span>);<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure>
<p>安装工具压测<br>要在计算机上安装 JMeter，请按照以下步骤进行操作：</p>
<p>下载 JMeter：</p>
<p>前往 Apache JMeter 的官方网站：<a href="https://jmeter.apache.org/">https://jmeter.apache.org/</a><br>导航至 Downloads 页面。<br>选择最新版本的 Apache JMeter，通常可以在页面顶部找到。确保选择与你的操作系统兼容的版本。<br>解压下载的文件：</p>
<p>下载完成后，解压缩下载的压缩文件。你可以使用文件压缩软件（如 WinRAR、7-Zip）进行解压缩。<br>解压后会得到一个文件夹，里面包含 JMeter 的可执行文件和其他必要文件。<br>启动 JMeter：</p>
<p>进入解压后的文件夹，在其中找到 JMeter 的可执行文件，它的名称可能是 jmeter.bat（Windows）或 jmeter.sh（Unix&#x2F;Linux）。<br>双击运行 jmeter.bat 或 jmeter.sh 文件，即可启动 JMeter。<br>验证安装：</p>
<p>当 JMeter 启动后，你会看到 JMeter 的 GUI（图形用户界面）。<br>如果 GUI 成功启动，表示 JMeter 已经成功安装并可以正常运行。<br>可选步骤 - 配置环境变量（仅限 Unix&#x2F;Linux）：</p>
<p>如果你在 Unix&#x2F;Linux 系统上使用 JMeter，你可能希望将 JMeter 添加到系统路径中，以便从任何位置运行 JMeter。<br>若要配置环境变量，请编辑 ~&#x2F;.bashrc 文件，并添加以下行：<br>ruby<br>Copy code<br>export PATH&#x3D;$PATH:&#x2F;path&#x2F;to&#x2F;jmeter&#x2F;bin<br>其中 &#x2F;path&#x2F;to&#x2F;jmeter 是你解压 JMeter 的文件夹的路径。<br>开始使用 JMeter：</p>
<p>启动 JMeter 后，你可以开始创建并运行测试计划，执行性能测试、接口测试等操作。你可以在 JMeter 的 GUI 中创建和管理测试计划，并使用不同的组件来模拟各种场景。<br>通过以上步骤，你应该可以成功下载、安装并启动 JMeter，并开始使用它进行性能测试和接口测试等任务。  </p>
<p>当使用 JMeter 创建并发请求时，你需要按照以下步骤操作：</p>
<p>启动 JMeter： 运行 JMeter，等待它完全加载。</p>
<p>创建测试计划： 在 JMeter 左侧的 Test Plan (测试计划) 上右键，选择 “Add” -&gt; “Threads (Users)” -&gt; “Thread Group”。这将添加一个线程组，你可以在其中定义并发用户的数量和其他配置。</p>
<p>添加 HTTP 请求： 在刚创建的线程组上右键，选择 “Add” -&gt; “Sampler” -&gt; “HTTP Request”。在 HTTP 请求的配置中，填入你的接口 URL：<a href="http://localhost:8088/stpweb/limited-resource.do?30610002=30610002%E3%80%82">http://localhost:8088/stpweb/limited-resource.do?30610002=30610002。</a></p>
<p>配置并发用户数： 在刚创建的线程组下，你可以设置并发用户的数量。可以在 “Number of Threads (users)” 字段中指定要模拟的并发用户数。</p>
<p>运行测试： 点击 JMeter 工具栏上的绿色运行按钮来启动测试。JMeter 将发送指定数量的并发请求到你的接口地址。</p>
<p>查看结果： 在测试执行完成后，你可以查看结果。可以使用 JMeter 提供的各种监听器（Listeners）来查看请求响应时间、吞吐量、错误率等性能指标。</p>
<p>以上是基本的步骤，你可以根据你的测试需求进一步调整配置，例如设置请求参数、添加断言、配置定时器等。JMeter 提供了丰富的功能和组件来满足不同场景下的测试需求，你可以根据具体情况进行使用。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
</search>
