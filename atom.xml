<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-03-19T09:45:08.505Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2024/03/19/Redis/Redis%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AF%B9%E6%AF%94/"/>
    <id>http://example.com/2024/03/19/Redis/Redis%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AF%B9%E6%AF%94/</id>
    <published>2024-03-19T09:45:08.505Z</published>
    <updated>2024-03-19T09:45:08.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RedisTemplate、Jedis、Lettuce、Redisson对比"><a href="#RedisTemplate、Jedis、Lettuce、Redisson对比" class="headerlink" title="RedisTemplate、Jedis、Lettuce、Redisson对比"></a>RedisTemplate、Jedis、Lettuce、Redisson对比</h1><p>以下是对以上Redis客户端库的对比分析。</p><h2 id="RedisTemplate"><a href="#RedisTemplate" class="headerlink" title="RedisTemplate"></a>RedisTemplate</h2><p>来源于Spring Data Redis, 它是Spring提供的一套对Redis进行操作的模板类。它的最大优点在于提供了对Key、String、List、Set、ZSet、Hash的操作抽象，其次是解决了在操作过程中的事务、批处理及Pipeline等问题，此外提供了对Redis Pub&#x2F;Sub模型的抽象。但是需要注意的是，它需要Spring环境的支撑存在。</p><h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持。Jedis用法简便，支持排序、连接池、管道等操作。另外，使用Jedis开发者需要提前了解redis所有命令和参数，才能开发出一个完善的系统，因此上手难度会比较大。</p><h2 id="Lettuce"><a href="#Lettuce" class="headerlink" title="Lettuce"></a>Lettuce</h2><p>Lettuce为Redis提供了 Scala，RxJava，和响应式编程模型以及命令式使用方法も提供している。Lettuce基于Netty框架。连接实例（StatefulRedisConnection）可以在多个线程间并发访问，应为StatefulRedisConnection是线程安全的。Lettuce的性能比Jedis更优，API更丰富一些。</p><h2 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h2><p>Redisson 是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用类，且这些分布式对象都是由Redis支持的，因此你可以把Redisson当成一个分布式的工具类库 。对于Redis的常规操作，你可以把Redisson当成Jedis的一个封装，对于复杂操作，你可以把Redisson当成一个功能丰富的客户端。</p><h2 id="使用便利度"><a href="#使用便利度" class="headerlink" title="使用便利度"></a>使用便利度</h2><ul><li><strong>RedisTemplate</strong>：其主要优点在于对Key、String、List、Set、ZSet、Hash等类型数据进行操作时，提供了一套抽象，使得我们可以更简单方便地进行操作。不足在于需要Spring环境支持。</li><li><strong>Jedis</strong>：Jedis的API提供了全面的Redis命令支持。不足在于上手难度大，因为使用Jedis需要开发者提前了解Redis所有命令和参数。</li><li><strong>Lettuce</strong>：提供了响应式编程模型，基于Netty框架，且是线程安全的。对于高并发的应用，无需像Jedis那样创建大量连接对象，减轻系统负担。缺点是需要对响应式编程有一定理解才能更好地使用。</li><li><strong>Redisson</strong>：提供了丰富的分布式对象和服务，可以当做分布式工具类库使用。且Redisson对于Redis的常规操作也提供了封装，使得操作更为便捷。</li></ul><h2 id="集成难易程度"><a href="#集成难易程度" class="headerlink" title="集成难易程度"></a>集成难易程度</h2><ul><li><strong>RedisTemplate</strong>：由于与Spring框架集成，如果是在Spring环境下开发，集成十分便捷。如果不是在Spring环境下，则需要额外配置才能使用。</li><li><strong>Jedis</strong>：Jedis的集成十分简单，但是可能需要编写额外的代码来支持连接池等特性。</li><li><strong>Lettuce</strong>：与Spring集成简单，Spring Boot也提供了自动配置。</li><li><strong>Redisson</strong>：Redisson与Spring集成较为方便，但使用其中的分布式对象或服务时可能需要更多配置。</li></ul><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ul><li><strong>RedisTemplate</strong>：性能受限于其内部使用的连接库，可能选择Jedis或者Lettuce。</li><li><strong>Jedis</strong>：Jedis在高并发的场景中性能可能会有 一些问题，原因是Jedis不是线程安全的，需要使用连接池管理Jedis连接。在大并发量下，Jedis连接因此可能会成为瓶颈。</li><li><strong>Lettuce</strong>：Lettuce基于Netty，其连接实例（StatefulRedisConnection）可以在多个线程间并发访问，因为StatefulRedisConnection是线程安全的。相比于Jedis，Lettuce的性能在高并发情况下更优。</li><li><strong>Redisson</strong>：性能强大，优于Jedis和Lettuce。Redisson提供了更多的功能和更高的性能，内部实现上，Redisson采用了Netty框架进行网络通信，同时内部采用了许多并发处理，使得其在并发处理方面具有了很高的效率。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在选择具体的Redis Java客户端时，需要综合考虑应用的具体需求、开发团队的技术栈、性能需求等。</p><ul><li>如果你的项目是基于Spring的，那么RedisTemplate可能是最方便的选择。</li><li>如果你的项目特别关注性能，并且并发量高，Lettuce或者Redisson会是更好的选择。</li><li>如果你需要更便捷地使用Redis提供的分布式工具类库，Redisson是一个不错的选择。</li></ul><p>最后还需要通过自己的实际使用和测试，以确定哪个客户端最适合自己的项目需求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RedisTemplate、Jedis、Lettuce、Redisson对比&quot;&gt;&lt;a href=&quot;#RedisTemplate、Jedis、Lettuce、Redisson对比&quot; class=&quot;headerlink&quot; title=&quot;RedisTemplate、Je</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2024/03/19/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B5%8B%E8%AF%84/"/>
    <id>http://example.com/2024/03/19/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B5%8B%E8%AF%84/</id>
    <published>2024-03-19T09:45:08.505Z</published>
    <updated>2024-03-19T09:45:08.505Z</updated>
    
    <content type="html"><![CDATA[<p>AWS亚马逊云账号注册 全球云服务器12个月免费试用详细教程</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;AWS亚马逊云账号注册 全球云服务器12个月免费试用详细教程&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>yml颜色显示灰色</title>
    <link href="http://example.com/2024/03/18/springboot/yml%E4%B8%8D%E7%94%9F%E6%95%88%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2024/03/18/springboot/yml%E4%B8%8D%E7%94%9F%E6%95%88%E9%97%AE%E9%A2%98/</id>
    <published>2024-03-17T16:00:00.000Z</published>
    <updated>2024-03-19T09:45:08.505Z</updated>
    
    <content type="html"><![CDATA[<p>确实，在Spring Boot项目中，<code>bootstrap.yml</code>文件的作用主要是用于系统启动时加载一些配置信息。例如，我们使用Spring Cloud Config配置中心时，就需要通过<code>bootstrap.yml</code>来指定Config Server的地址。将<code>bootstrap.yml</code>与<code>application.yml</code>同时使用时，<code>bootstrap.yml</code>配置的优先级更高。</p><p>如果<code>bootstrap.yml</code>没有生效，通常原因可能是你的Spring Cloud项目缺少相应的依赖。请按照以下步骤操作：</p><ul><li>方法一：<br>第一步，你需要在项目中添加spring-cloud-starter-bootstrap的依赖：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>方法二：<br>如果方法一不起作用，那么可以尝试仅引入spring-cloud-context：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意：<code>$&#123;spring-cloud.version&#125;</code>中的版本号需要与你使用的Spring boot版本对应。</p><p>最后，确保你正确配置了<code>bootstrap.yml</code>文件，并将其放在<code>src/main/resources</code>文件夹下。如有必要，可以尝试删除原有配置文件并重新创建一份新的配置文件以确保所有配置都是最新的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;确实，在Spring Boot项目中，&lt;code&gt;bootstrap.yml&lt;/code&gt;文件的作用主要是用于系统启动时加载一些配置信息。例如，我们使用Spring Cloud Config配置中心时，就需要通过&lt;code&gt;bootstrap.yml&lt;/code&gt;来指定Co</summary>
      
    
    
    
    <category term="springboot" scheme="http://example.com/categories/springboot/"/>
    
    
  </entry>
  
  <entry>
    <title>建立自己的博客</title>
    <link href="http://example.com/2024/03/12/%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
    <id>http://example.com/2024/03/12/%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B/</id>
    <published>2024-03-11T16:00:00.000Z</published>
    <updated>2024-03-19T09:45:08.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h1><h2 id="1-安装-Node-js-和-npm"><a href="#1-安装-Node-js-和-npm" class="headerlink" title="1. 安装 Node.js 和 npm"></a>1. 安装 Node.js 和 npm</h2><ul><li>前往 <a href="https://nodejs.org/">Node.js 官网</a> 下载并安装最新版本的 Node.js。</li><li>安装完成后，你可以在命令行中运行以下命令来验证是否成功安装：<br>node -v<br>npm -v</li></ul><p>Copy code</p><h2 id="2-安装-Git"><a href="#2-安装-Git" class="headerlink" title="2. 安装 Git"></a>2. 安装 Git</h2><ul><li>如果你的系统中还没有安装 Git，你可以在 <a href="https://git-scm.com/">Git 官网</a> 下载并安装。</li><li>安装完成后，你可以在命令行中运行以下命令来验证是否成功安装：<br>git –version</li></ul><h2 id="3-全局安装-Hexo"><a href="#3-全局安装-Hexo" class="headerlink" title="3. 全局安装 Hexo"></a>3. 全局安装 Hexo</h2><ul><li>打开命令行终端，运行以下命令来全局安装 Hexo-cli：<br>npm install -g hexo-cli</li></ul><p>markdown<br>Copy code</p><h2 id="4-初始化-Hexo-项目"><a href="#4-初始化-Hexo-项目" class="headerlink" title="4. 初始化 Hexo 项目"></a>4. 初始化 Hexo 项目</h2><ul><li>在你想要创建 Hexo 博客的目录中，打开命令行终端，运行以下命令来初始化一个新的 Hexo 项目：<br>hexo init myblog</li></ul><h2 id="5-进入项目目录并安装依赖"><a href="#5-进入项目目录并安装依赖" class="headerlink" title="5. 进入项目目录并安装依赖"></a>5. 进入项目目录并安装依赖</h2><ul><li><p>进入项目目录：<br>cd myblog</p></li><li><p>在项目目录中运行以下命令来安装项目所需的依赖：<br>npm install</p></li></ul><h2 id="6-启动本地服务器"><a href="#6-启动本地服务器" class="headerlink" title="6. 启动本地服务器"></a>6. 启动本地服务器</h2><ul><li>在项目目录中运行以下命令来启动 Hexo 的本地服务器：<br>hexo server</li></ul><p>less</p><ul><li>这将启动一个本地服务器，默认情况下访问地址为 <a href="http://localhost:4000/">http://localhost:4000</a>。</li></ul><p>现在，你已经成功安装和初始化了 Hexo 项目。你可以开始编写文章、定制主题，并通过部署将博客发布到线上。<br>这是一个使用Markdown格式编写的Hexo安装步骤，你可以将其保存为.md文件，然后在Hexo博客中使用。</p><h2 id="部署GitHub-Pages"><a href="#部署GitHub-Pages" class="headerlink" title="部署GitHub Pages"></a>部署GitHub Pages</h2><p>我们假定你已经有一个GitHub账号而且已经配置好git了，不知道应该怎么做的话可以参考这篇博客。</p><p>现在新建一个仓库（Create a new repository），Repository name填写为&lt;你的GitHub用户名&gt;.github.io，例如“ChaoiteC.github.io”，同时仓库可见性必须为Public（对所有人可见）。</p><p>如果操作正确，你会在仓库设置中找到Page选项。</p><p>现在打开博客根目录下的_config.yml，找到Deployment相关配置项，如下填写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">deploy:<br>  <span class="hljs-built_in">type</span>: git<br>  repo: git@github.com:&lt;你的GitHub用户名&gt;/&lt;你的GitHub用户名&gt;.github.io.git<br>  branch: main<br></code></pre></td></tr></table></figure><p>你可能注意到官方文档与一些其他教程中repo项填写的是http链接，这也是可以的，但在使用GitHub Actions部署时可能会遭遇拒绝访问的问题。</p><p>安装hexo-deployer-git:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>执行下面命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean<br>$ hexo g<br>$ hexo deploy 或者简写为： $ hexo d<br>或者简写为：<br><br>bash<br>Copy code<br>$ hexo d -g<br></code></pre></td></tr></table></figure><p>deploy命令会将public目录中的文件和目录推送至_config.yml中指定的远端仓库和分支中，并且完全覆盖该分支下的已有内容。</p><p>如果一切工作正常，现在你可以在&lt;你的GitHub用户名&gt;.github.io中看到网站内容。</p><p>##GitHub Actions自动部署（可选）<br>我们很快注意到，一旦你离开现在使用的设备，你就无法修改网站内容。当你更换设备时，你不得不将上述步骤全部重复。一旦设备出现故障更是会损失惨重。这些矛盾呼吁我们采取方法，要求我们能自动地储存与部署博客文件，而不受手上设备的限制。</p><p>GitHub Actions为我们在需要的时候创建一个容器，我们在容器中安装软件并处理我们的博客文件，最后部署到Pages仓库中。现在我们来实现它。</p><p>前提<br>首先在Github上新建一个仓库用来储存我们的博客文件，通常我们将其设为私有的。</p><p>如果你安装了VS Code，这时候你可以在博客根目录右键菜单中选择“在终端中打开”来启动Windows Powershell，然后输入并执行：</p><p>code .<br>此命令将会启动VS Code并在其中打开这个文件夹。然后你可以在侧边栏中打开源代码管理页面，从GitHub添加远程库。只需要按照提示操作，你最终能将整个目录下的文件上传到仓库中（被.gitignore指定的文件&#x2F;文件夹不会上传）。</p><p>我们将上面内容视为准备操作，如果你不知道如何操作，可以寻求搜索引擎的帮助。</p><p>部署密钥<br>现在在“git bash here”中执行下面命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-keygen -f github-deploy-key<br></code></pre></td></tr></table></figure><p>这个命令将生成部署密钥，你只需要一直按空格，根目录下就会出现两个文件：github-deploy-key和github-deploy-key.pub。</p><p>注意</p><p>正如其名字，除非你确定自己在做什么，否则你不应该将密钥直接上传到仓库（尤其是公共仓库）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">在博客源文件仓库中依序打开Settings-&gt;Secrets and variables-&gt;Actions-&gt;New repository secret。<br></code></pre></td></tr></table></figure><p>在Name中填写“HEXO_DEPLOY_PRI”，在Value中填写github-deploy-key文件中的全部内容（包括头尾的文字）。然后Add secret。</p><p>在Page仓库中依序打开Settings-&gt;Deploy keys-&gt;Add deploy key。</p><p>在Title中填写“HEXO_DEPLOY_PUB”，在Key中填写github-deploy-key.pub文件中的全部内容，勾选Allow write access，然后Add key。</p><p>配置GitHub Actions<br>在博客根目录下创建.github&#x2F;workflows&#x2F;deploy.yml文件，目录结构如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>└── .github<br>    └── workflows<br>        └── deploy.yml<br>在deploy.yml文件中粘贴下面内容并在对应地方作改动。<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Action&#x27;s Name</span><br>name: AutoDeploy<br><br>on:<br>  <span class="hljs-comment"># Triggering Condition 1 Main Branch Performs The Task After Receiving Push</span><br>  push:<br>    branches:<br>      - main<br>  <span class="hljs-comment"># Triggering Condition 2 Manual Button</span><br>  workflow_dispatch:<br><br><span class="hljs-comment"># Putting Environment Variables Here You Need To Replace It With Your Own</span><br><span class="hljs-built_in">env</span>:<br>  <span class="hljs-comment"># After Hexo Compiles Use This Git User To Deploy To The Github Warehouse</span><br>  GIT_USER: &lt;你的GitHub用户名&gt;<br>  <span class="hljs-comment"># After Hexo Compiles Use This Git Mailbox To Deploy To The Github Warehouse</span><br>  GIT_EMAIL: &lt;你的GitHub用户邮箱&gt;<br>  <span class="hljs-comment"># The Git Hub Warehouse To Be Deployed After Hexo Compiles</span><br>  GIT_DEPLOY_REPO: &lt;你的GitHub用户名&gt;/&lt;你的GitHub用户名&gt;.github.io<br>  <span class="hljs-comment"># Hexo Compiles The Branch To Deploy After Compilation</span><br>  GIT_DEPLOY_BRANCH: main<br><br><span class="hljs-built_in">jobs</span>:<br>  build:<br>    name: Build on node <span class="hljs-variable">$&#123;&#123; matrix.node_version &#125;</span>&#125; and <span class="hljs-variable">$&#123;&#123; matrix.os &#125;</span>&#125;<br>    runs-on: ubuntu-latest<br>    <span class="hljs-keyword">if</span>: github.event.repository.owner.id == github.event.sender.id<br>    strategy:<br>      matrix:<br>        os: [ubuntu-latest]<br>        node_version: [16.x]<br><br>    steps:<br>      - name: Checkout<br>        uses: actions/checkout@v4<br><br>      - name: Checkout deploy repo<br>        uses: actions/checkout@v4<br>        with:<br>          repository: <span class="hljs-variable">$&#123;&#123; env.GIT_DEPLOY_REPO &#125;</span>&#125;<br>          ref: <span class="hljs-variable">$&#123;&#123; env.GIT_DEPLOY_BRANCH &#125;</span>&#125;<br>          path: .deploy_git<br><br>      - name: Use Node.js <span class="hljs-variable">$&#123;&#123; matrix.node_version &#125;</span>&#125;<br>        uses: actions/setup-node@v1<br>        with:<br>          node-version: <span class="hljs-variable">$&#123;&#123; matrix.node_version &#125;</span>&#125;<br><br>      - name: Configuration environment<br>        <span class="hljs-built_in">env</span>:<br>          HEXO_DEPLOY_PRI: <span class="hljs-variable">$&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;</span>&#125;<br>        run: |<br>          sudo timedatectl set-timezone <span class="hljs-string">&quot;Asia/Shanghai&quot;</span><br>          <span class="hljs-built_in">mkdir</span> -p ~/.ssh/<br>          <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$HEXO_DEPLOY_PRI</span>&quot;</span> &gt; ~/.ssh/id_rsa<br>          <span class="hljs-built_in">chmod</span> 600 ~/.ssh/id_rsa<br>          ssh-keyscan -t rsa github.com &gt;&gt; ~/.ssh/known_hosts<br>          git config --global user.name <span class="hljs-variable">$GIT_USER</span><br>          git config --global user.email <span class="hljs-variable">$GIT_EMAIL</span><br><br>      - name: Install dependencies<br>        run: |<br>          npm install hexo-cli -g<br>          <span class="hljs-comment"># Install According To The Components You Installed</span><br>          npm install - gulp gulp-uglify hexo hexo-deployer-git hexo-generator-archive hexo-generator-category hexo-generator-feed hexo-generator-index hexo-generator-search hexo-generator-searchdb hexo-generator-sitemap hexo-generator-tag hexo-renderer-ejs hexo-renderer-marked hexo-renderer-pug hexo-renderer-stylus hexo-server hexo-tag-cloud hexo-word-counter readable-stream uglify-es --save<br><br>      - name: Deploy hexo<br>        run: |<br>          npm run deploy<br></code></pre></td></tr></table></figure><p>现在你可以尝试在博客源文件仓库中作一点改动并推送到远程库，接着在仓库的Actions页面中观察工作是否正常（不被打红叉）。如果正常，大约在1-2分钟内会完成自动部署任务，你能在Pages上确认到更改。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;安装-Hexo&quot;&gt;&lt;a href=&quot;#安装-Hexo&quot; class=&quot;headerlink&quot; title=&quot;安装 Hexo&quot;&gt;&lt;/a&gt;安装 Hexo&lt;/h1&gt;&lt;h2 id=&quot;1-安装-Node-js-和-npm&quot;&gt;&lt;a href=&quot;#1-安装-Node-js-和-</summary>
      
    
    
    
    <category term="建站" scheme="http://example.com/categories/%E5%BB%BA%E7%AB%99/"/>
    
    
  </entry>
  
  <entry>
    <title>案例分析</title>
    <link href="http://example.com/2024/03/12/ruankao/%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2024/03/12/ruankao/%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/</id>
    <published>2024-03-11T16:00:00.000Z</published>
    <updated>2024-03-19T09:45:08.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="必背知识点"><a href="#必背知识点" class="headerlink" title="必背知识点"></a>必背知识点</h2><h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><p>质量属性<br>性能，可靠性，可用性，安全性，可修改性，互操作性，功能性，可变性</p><p>敏感点:为了实现某种特定的质量属性，一个或者多个构件所具有的特性。  </p><p>权衡点：影响多个质量属性的特性，是多个质量属性的敏感点。  </p><p>架构风险：是一种常规概念，既可能引起风险的因素，称为风险点。某个做法如果有隐患，有可能 导致一些问题，就成为风险点，如果某件事情可行，是可接受的，则是非风险点。</p><h2 id="架构风格"><a href="#架构风格" class="headerlink" title="架构风格"></a>架构风格</h2><p>概念<br>什么是架构风格</p><ul><li>软件体系结构风格是描述某一特定应用领域中系统组织方式的惯用模式。架构风格定义一个系统家族，即-个架构定义、一个词汇表和一组约束。词汇表中包含一些构件和连接件类型，而这组约束指出系统是如何将这些构件和连接件组合起来的。</li><li>架构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将各个模块和子系统有效地组织成一个完整的系统。对软件架构风格的研究和实践促进对设计的重用，一些经过实践证实的解决方案也可以可靠地用于解决新的问题。</li><li>架构设计的一个核心问题是能否达到架构级的软件复用<br>架构风格定义了用于描述系统的术语表和一组指导构建系统的规则，</li></ul><h2 id="架构风格分类"><a href="#架构风格分类" class="headerlink" title="架构风格分类"></a>架构风格分类</h2><h3 id="数据流风格"><a href="#数据流风格" class="headerlink" title="数据流风格"></a>数据流风格</h3><p>批处理<br>管道过滤器<br>二者区别在于批处理前后构件不一定有关联，并且是作为整体传递，即必须前一个执行完才能执行下一个。管道-过滤器是前一个输出作为后一个输入，前面执行到部分可以开始下一个的执行。<br>优点：独立性好，复用性好，可扩展良好<br>缺点：交互性差</p><h3 id="调用返回风格"><a href="#调用返回风格" class="headerlink" title="调用返回风格"></a>调用返回风格</h3><p>◆主程序&#x2F;子程序:单线程控制，把问题划分为若干个处理步骤，构件即为主程序和子程序，子程序通常可合成为模块。过程调用作为交互机制，充当连接件的角色。个人认为netty符合这种模式 主程序处理连接 子程序处理请求<br>◆面向对象:构件是对象，对象是抽象数据类型的实例。连接件即使对象间交互的方式对象是通过函数和过程的调用来交互的，<br>◆层次结构:构件组成一个层次结构，连接件通过决定层间如何交互的协议来定义。每层为上一层提供服务，使用下一层的服务，只能见到与自己邻接的层。修改某一层，最多影响其相邻的两层(通常只能影响上层)<br>◆层次结构优点:支持基于可增加抽象层的设计，允许将一个复杂问题分解成一个增量步序列的实现。<br>  不同的层次处于不同的抽象级别，越靠近底层，抽象级别越高。<br>  由于每一层最多只影响两层，同时只要给相邻层提供相同的接口，允许每层用不同的方法实现，同样为软件复用提供了强大的支持。<br>◆缺点:<br>1.并不是每个系统都可以很容易的划分为分层的模式。<br>2.很难找到一个合适的、正确的层次抽象方法。</p><h3 id="独立构件风格"><a href="#独立构件风格" class="headerlink" title="独立构件风格"></a>独立构件风格</h3><p>进程通信<br>事件驱动系统 （隐式调用） （题目字眼 <span style="color:blue">事件</span>）</p><h3 id="仓库风格"><a href="#仓库风格" class="headerlink" title="仓库风格"></a>仓库风格</h3><p>优点：交互性好，可扩展性好（相比数据流风格此风格可扩展性更好）<br>缺点：</p><h3 id="虚拟机风格"><a href="#虚拟机风格" class="headerlink" title="虚拟机风格"></a>虚拟机风格</h3><p>解释器 （题目字眼 ，一般题目描述出现 <span style="color:blue">可视化 解释代码 可视化编程</span> 等都是这种风格）<br>基于规则的系统</p><h3 id="闭环"><a href="#闭环" class="headerlink" title="闭环"></a>闭环</h3><h3 id="C2风格"><a href="#C2风格" class="headerlink" title="C2风格"></a>C2风格</h3><p>工作模式:双机热备模式;双机互备模式;双机双工模式。 这几个区别是啥</p><p>这个问题的描述在各种应用环境下可能有不同的解释，但是这里我们主要从计算机网络和服务器集群的角度进行解析。一般而言，这些模式涉及到两台服务器如何进行协作以提供服务，主要区别在于它们如何共享负载以及处理故障。</p><ol><li><p>双机热备模式：在双机热备模式中，两台服务器中有一台作为主服务器（主节点）提供服务，另一台作为备份服务器（备份节点）处于热备份状态。也就是说备份服务器已经启动并准备好接管服务，但在正常情况下并不提供服务。一旦主服务器出现故障，备份服务器立即接管并提供服务，以此保持服务的连续性。这种模式的优点是可以在服务器故障时快速切换，缺点是备份服务器的资源在空闲状态下并未得到充分利用。</p></li><li><p>双机互备模式：在双机互备模式中，两台服务器都可以提供服务，也可以作为对方的备份。两台服务器在正常情况下都提供一部分服务，当一台服务器故障时，另一台服务器会接管故障服务器的服务。这种模式充分利用了服务器资源，即使一台服务器出现故障，也只会影响到一部分服务。</p></li><li><p>双机双工模式（双活模式）：在双机双工模式中，两台服务器均在运行状态，并共同承担服务负载。在正常情况下，服务请求会在两台服务器之间均衡分配。当一台服务器发生故障时，另一台服务器将接管所有的服务负载。这种模式的优点 是充分利用系统资源，并且提供了良好的服务容错能力。然而，这种模式需要复杂的负载均衡和故障切换机制。</p></li></ol><p>综上所述，三种模式主要的区别在于如何分配服务负载以及如何处理服务器故障。各种模式都有各自的优点和局限，选择哪种模式主要取决于应用的具体需求和环境。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;必背知识点&quot;&gt;&lt;a href=&quot;#必背知识点&quot; class=&quot;headerlink&quot; title=&quot;必背知识点&quot;&gt;&lt;/a&gt;必背知识点&lt;/h2&gt;&lt;h3 id=&quot;基本知识&quot;&gt;&lt;a href=&quot;#基本知识&quot; class=&quot;headerlink&quot; title=&quot;基本知识&quot;</summary>
      
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis实现限流和分布式锁</title>
    <link href="http://example.com/2024/03/12/Redis/Redis%E9%94%81/"/>
    <id>http://example.com/2024/03/12/Redis/Redis%E9%94%81/</id>
    <published>2024-03-11T16:00:00.000Z</published>
    <updated>2024-03-19T09:45:08.505Z</updated>
    
    <content type="html"><![CDATA[<p>##Redis实现限流和分布式锁<br>首先添加jar包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;dependency&gt;<br>&lt;groupId&gt;org.redisson&lt;/groupId&gt;<br>&lt;artifactId&gt;redisson&lt;/artifactId&gt;<br>&lt;version&gt;3.24.3&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>如果缺少类请查看这个地址<br><a href="https://mvnrepository.com/artifact/org.redisson/redisson/3.24.3">https://mvnrepository.com/artifact/org.redisson/redisson/3.24.3</a><br>他会显示这个包所相关的jar包和版本号<br>然后就是配置redisson  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">package com.rfca.config;<br><br>import org.redisson.Redisson;<br>import org.redisson.config.Config;<br>import org.springframework.context.annotation.Bean;<br>import org.springframework.stereotype.Component;<br><br>@Component<br>public class RedisConfig &#123;<br>    // 1. Create config object<br>    @Bean<br>    public Redisson <span class="hljs-function"><span class="hljs-title">redisson</span></span>() &#123;<br><br>        Config config = new Config();<br><br>        config.useSingleServer()<br>                .setAddress(<span class="hljs-string">&quot;redis://127.0.0.1:6379&quot;</span>)<br>                .setPassword(<span class="hljs-string">&quot;12345&quot;</span>); // 替换为你的 Redis 密码<br>        <span class="hljs-built_in">return</span> (Redisson) Redisson.create(config);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>当我们实现高并发的时候，还需要考虑限流<br>这是我的一个实现类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs bash">package com.rfca.config;<br><br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.stereotype.Component;<br>import redis.clients.jedis.ShardedJedis;<br>import redis.clients.jedis.ShardedJedisPool;<br><br>@Component<br>public class RateLimiter &#123;<br>    @Autowired<br>    private ShardedJedisPool shardedJedisPool;<br><br>    public boolean isAllowed(String key, int <span class="hljs-built_in">limit</span>, int windowSizeInSeconds) &#123;<br>        try (ShardedJedis jedis = shardedJedisPool.getResource()) &#123;<br>            String redisKey = String.format(<span class="hljs-string">&quot;rate_limiter:%s&quot;</span>, key);<br><br>            // 获取当前时间戳<br>            long timestamp = System.currentTimeMillis() / 1000;<br><br>            // 获取窗口起始时间<br>            long windowStart = timestamp - windowSizeInSeconds;<br><br>            // 统计窗口内的请求数量<br>            long count = jedis.zcount(redisKey, windowStart, timestamp);<br><br>            // 判断是否允许请求<br>            <span class="hljs-built_in">return</span> count &lt; <span class="hljs-built_in">limit</span>;<br>        &#125; catch (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-built_in">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>编写测试代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs bash">@GetMapping(<span class="hljs-string">&quot;/limited-resource&quot;</span>)<br>    public ResponseEntity&lt;String&gt; accessLimitedResource(HttpServletRequest request) &#123;<br>        String key = <span class="hljs-string">&quot;resourceAccessKey&quot;</span>; // 用于标识资源的键<br>        int <span class="hljs-built_in">limit</span> = 10000; // 限制次数<br>        int windowSizeInSeconds = 60; // 时间窗口，例如1分钟<br><br>        boolean isAllowed = rateLimiter.isAllowed(key, <span class="hljs-built_in">limit</span>, windowSizeInSeconds);<br>        <span class="hljs-keyword">if</span> (isAllowed) &#123;<br>            // 获取缓存<br>            String keyparam = request.getParameter(<span class="hljs-string">&quot;30610002&quot;</span>);<br>            RBucket&lt;Integer&gt; bucket = redisson.getBucket(keyparam); // 获取 RBucket 对象<br>            String lock = <span class="hljs-string">&quot;mylock&quot;</span>; // 此处使用全局锁，可以针对不同资源进行加锁，减少锁的粒度<br>            RLock lock1 = redisson.getLock(lock);<br>            Integer nums1 = bucket.get();<br>            <span class="hljs-keyword">if</span> (nums1 == 0) &#123;<br>                log.info(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>                <span class="hljs-built_in">return</span> ResponseEntity.status(HttpStatus.TOO_MANY_REQUESTS).body(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>            &#125;<br>            lock1.lock();//阻塞式等待，默认加的锁都是30s时间<br>            try &#123;<br>                log.info(<span class="hljs-string">&quot;加锁成功，执行业务...&quot;</span> + Thread.currentThread().getId()); // 打印获取到锁的线程ID<br>                Integer nums = bucket.get();<br>                <span class="hljs-keyword">if</span> (nums != null &amp;&amp; nums &gt; 0) &#123;<br>                    String parkingLotId = request.getParameter(<span class="hljs-string">&quot;30610002&quot;</span>);<br>                    SelectByparkinglotidResult selectByparkinglotidResult = monthlyCardRulesMapper.selectByparkinglotid(parkingLotId).get(0);<br>                    MonthlyCardRules monthlyCardRules = new MonthlyCardRules();<br>                    monthlyCardRules.setId(selectByparkinglotidResult.getId());<br>                    monthlyCardRules.setNums(nums - 1);<br>                    monthlyCardRulesMapper.updateByPrimaryKeySelective(monthlyCardRules);<br>                    log.info(<span class="hljs-string">&quot;更新成功&quot;</span>);<br>                    bucket.set(nums - 1);<br>                    <span class="hljs-built_in">return</span> ResponseEntity.ok(<span class="hljs-string">&quot;请求成功&quot;</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    log.info(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>                    <span class="hljs-built_in">return</span> ResponseEntity.status(HttpStatus.TOO_MANY_REQUESTS).body(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>                &#125;<br>            &#125; catch (Exception e) &#123;<br>                log.info(<span class="hljs-string">&quot;获取锁失败&quot;</span>);<br>                <span class="hljs-built_in">return</span> ResponseEntity.ok(<span class="hljs-string">&quot;没有抢到&quot;</span>);<br>            &#125; finally &#123;<br>                <span class="hljs-keyword">if</span> (lock1.isHeldByCurrentThread()) &#123;<br>                    log.info(<span class="hljs-string">&quot;释放锁...&quot;</span> + Thread.currentThread().getId());<br>                    lock1.unlock();<br>                &#125;<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">return</span> ResponseEntity.status(HttpStatus.TOO_MANY_REQUESTS).body(<span class="hljs-string">&quot;请求过多，请稍后再试&quot;</span>);<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>安装工具压测<br>要在计算机上安装 JMeter，请按照以下步骤进行操作：</p><p>下载 JMeter：</p><p>前往 Apache JMeter 的官方网站：<a href="https://jmeter.apache.org/">https://jmeter.apache.org/</a><br>导航至 Downloads 页面。<br>选择最新版本的 Apache JMeter，通常可以在页面顶部找到。确保选择与你的操作系统兼容的版本。<br>解压下载的文件：</p><p>下载完成后，解压缩下载的压缩文件。你可以使用文件压缩软件（如 WinRAR、7-Zip）进行解压缩。<br>解压后会得到一个文件夹，里面包含 JMeter 的可执行文件和其他必要文件。<br>启动 JMeter：</p><p>进入解压后的文件夹，在其中找到 JMeter 的可执行文件，它的名称可能是 jmeter.bat（Windows）或 jmeter.sh（Unix&#x2F;Linux）。<br>双击运行 jmeter.bat 或 jmeter.sh 文件，即可启动 JMeter。<br>验证安装：</p><p>当 JMeter 启动后，你会看到 JMeter 的 GUI（图形用户界面）。<br>如果 GUI 成功启动，表示 JMeter 已经成功安装并可以正常运行。<br>可选步骤 - 配置环境变量（仅限 Unix&#x2F;Linux）：</p><p>如果你在 Unix&#x2F;Linux 系统上使用 JMeter，你可能希望将 JMeter 添加到系统路径中，以便从任何位置运行 JMeter。<br>若要配置环境变量，请编辑 ~&#x2F;.bashrc 文件，并添加以下行：<br>ruby<br>Copy code<br>export PATH&#x3D;$PATH:&#x2F;path&#x2F;to&#x2F;jmeter&#x2F;bin<br>其中 &#x2F;path&#x2F;to&#x2F;jmeter 是你解压 JMeter 的文件夹的路径。<br>开始使用 JMeter：</p><p>启动 JMeter 后，你可以开始创建并运行测试计划，执行性能测试、接口测试等操作。你可以在 JMeter 的 GUI 中创建和管理测试计划，并使用不同的组件来模拟各种场景。<br>通过以上步骤，你应该可以成功下载、安装并启动 JMeter，并开始使用它进行性能测试和接口测试等任务。  </p><p>当使用 JMeter 创建并发请求时，你需要按照以下步骤操作：</p><p>启动 JMeter： 运行 JMeter，等待它完全加载。</p><p>创建测试计划： 在 JMeter 左侧的 Test Plan (测试计划) 上右键，选择 “Add” -&gt; “Threads (Users)” -&gt; “Thread Group”。这将添加一个线程组，你可以在其中定义并发用户的数量和其他配置。</p><p>添加 HTTP 请求： 在刚创建的线程组上右键，选择 “Add” -&gt; “Sampler” -&gt; “HTTP Request”。在 HTTP 请求的配置中，填入你的接口 URL：<a href="http://localhost:8088/stpweb/limited-resource.do?30610002=30610002%E3%80%82">http://localhost:8088/stpweb/limited-resource.do?30610002=30610002。</a></p><p>配置并发用户数： 在刚创建的线程组下，你可以设置并发用户的数量。可以在 “Number of Threads (users)” 字段中指定要模拟的并发用户数。</p><p>运行测试： 点击 JMeter 工具栏上的绿色运行按钮来启动测试。JMeter 将发送指定数量的并发请求到你的接口地址。</p><p>查看结果： 在测试执行完成后，你可以查看结果。可以使用 JMeter 提供的各种监听器（Listeners）来查看请求响应时间、吞吐量、错误率等性能指标。</p><p>以上是基本的步骤，你可以根据你的测试需求进一步调整配置，例如设置请求参数、添加断言、配置定时器等。JMeter 提供了丰富的功能和组件来满足不同场景下的测试需求，你可以根据具体情况进行使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;##Redis实现限流和分布式锁&lt;br&gt;首先添加jar包&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>2022案例分析</title>
    <link href="http://example.com/2024/03/12/ruankao/2022%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2024/03/12/ruankao/2022%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/</id>
    <published>2024-03-11T16:00:00.000Z</published>
    <updated>2024-03-19T09:45:08.505Z</updated>
    
    <content type="html"><![CDATA[<p>【说明】<br>某电子商务公司拟升级其会员与促销管理系统，向用户提供个性化服务，提高用户的粘性。在项目立项之初，公司领导层一致认为本次升级的主要目标是提升会员管理方式的灵活性，由于当前用户规模不大，业务也相对简单，系统性能方面不做过多考虑。新系统除了保持现有的四级固定会员制度外，还需要根据用户的消费金额、偏好、重复性等相关特征动态调整商品的折扣力度，并支持在特定的活动周期内主动筛选与活动主题高度相关的用户集合，提供个性化的打折促销活动。<br>在需求分析与架构设计阶段，公司提出的需求和质量属性描述如下:<br>(a)管理员能够在页面上灵活设置折扣力度规则和促销活动逻辑，设置后即可生效;(互操作性)<br>(b)系统应该具备完整的安全防护措施，支持对恶意攻击行为进行检测与报警;（安全性）<br>(c)在正常负载情况下，系统应在0.3秒内对用户的界面操作请求进行响应;（性能）<br>(d)用户名是系统唯一标识，要求以字母开头，由数字和字母组合而成，长度不少于6个字符:（功能性）<br>(e)在正常负载情况下，用户支付商品费用后在3秒内确认订单支付信息;（性能）<br>(f)系统主站点电力中断后，应在5秒内将请求重定向到备用站点;（可用性）<br>(g)系统支持横向存储扩展，要求在2人天内完成所有的扩展与测试工作;（可修改性）第一次判断为（可测试性）判断错误<br>(h)系统宕机后，需要在10秒内感知错误，并自动启动热备份系统;（可用性）<br>(i)系统需要内置接口函数，支持开发团队进行功能调试与系统诊断;（可测试性）<br>(j)系统需要为所有的用户操作行为进行详细记录，便于后期查阅与审计;（安全性）<br>(k)支持对系统的外观进行调整和配置，调整工作需要在4人天内完成。（可修改性）在对系统需求、质量属性描述和架构特性进行分析的基础上，系统架构师给出了两种候选的架构设计方案，公司目前正在组织相关专家对系统架构进行评估。<br>1安全性 2可修改性 3e 4j 5h 6 k<br>补充知识：质量属性有那些：性能，可靠性，可用性，安全性，可修改性，功能性，可变性（体系结构扩充变更），互操作性<br>问题2<br>使用解释器风格<br>折扣规则可改性 解释器风格可以灵活配置新的规则，只需要导入配置或者新增解释规则就行，可以灵活的修改，面相对象则需要修改具体的类，具体的方法。<br>灵活性     解释器风格可以灵活的设计规则计算表达式，灵活性较好，面相对象需要使用策略模式具体实现对应的类和方法，灵活性较差。<br>性能 面向对象使用预先编译的方式，解释器需要动态解析绑定，性能方面略优，但是本系统对性能的要求不是特别高，综合考虑使用解释器风格更好。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;【说明】&lt;br&gt;某电子商务公司拟升级其会员与促销管理系统，向用户提供个性化服务，提高用户的粘性。在项目立项之初，公司领导层一致认为本次升级的主要目标是提升会员管理方式的灵活性，由于当前用户规模不大，业务也相对简单，系统性能方面不做过多考虑。新系统除了保持现有的四级固定会员制</summary>
      
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    
  </entry>
  
</feed>
